# 六大原则

- 单一职责原则（Single Responsibility Principle）；
- 开闭原则（Open Closed Principle）；
- 里氏替换原则（Liskov Substitution Principle）；
- 迪米特法则（Law of Demeter），又叫“最少知道法则”；
- 接口隔离原则（Interface Segregation Principle）；
- 依赖倒置原则（Dependence Inversion Principle）。

从多个角度阐述这几个原则：

- 是什么
- 解决了什么问题
- 带来了什么收益
- 解决方案有哪些

# 单一职责

定义：指的是一个类应该只有一个职责，也就是说，一个类应该只负责一项功能。

解决的问题：

- 单一变量。为了避免一个类承担过多的职责，从而导致类的复杂性增加、耦合度提高、可维护性下降等问题。
- 稳定性。如果一个类承担的职责过多，一旦其中一个职责需要修改，就可能影响到其他职责，导致代码的不稳定性。

收益：

- 降低类的复杂度
- 增加代码的可读性
- 提高代码的可维护性
- 降低变更所引起的风险

具体实现方式：

- 定义类的职责。在设计类时，应该明确类的职责是什么，确保类只负责一项功能或者一组相关的功能。
- 拆分类。如果一个类承担了多项职责，就应该考虑将其拆分成多个类，每个类只负责一个职责，从而降低类的复杂度，提高代码的可读性和可维护性。
- 避免过度设计。在设计类时，不应该过度考虑未来的可能性，而应该关注当前需求，尽可能的避免为了应对未来的需求而添加过多的职责。
- 应用接口隔离原则。接口隔离原则是单一职责原则的一个补充，它强调接口的职责应该尽可能单一，避免接口过于臃肿和复杂。
- 关注类的粒度。在拆分类时，需要考虑类的粒度问题，避免类过于细粒度或者过于粗粒度，应该根据实际需求来确定类的粒度。

# 开闭原则

定义：指一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。

解决的问题：

- 架构的可维护性
- 架构的可扩展性
- 保持原有代码的稳定性

收益：

- 降低系统维护成本。开闭原则可以让系统的代码更加稳定和灵活，从而减少需求变更对代码的影响，降低维护成本。
- 提高代码的可读性和可理解性。开闭原则可以使系统的结构更加清晰、易于理解，从而提高代码的可读性和可理解性。
- 提高代码的复用性。开闭原则可以让系统的代码更加可复用，从而提高代码的复用性。
- 提高系统的可扩展性。开闭原则可以让系统更加灵活、易于扩展，从而提高系统的可扩展性。
- 促进团队协作。遵循开闭原则可以使系统的代码更加稳定、可读性更高，从而促进团队协作，减少代码维护时的困难和误解。

具体实现方式：

- 使用`接口和抽象类`。通过使用接口和抽象类定义规范，可以使具体的实现类和抽象类解耦，从而提高代码的灵活性和可扩展性。
- 使用`策略模式`。通过将算法封装在独立的策略类中，并通过接口或抽象类定义策略规范，可以实现算法的动态替换，从而使程序更加灵活、可扩展。
- 使用`装饰器模式`。通过将对象封装在装饰器类中，并通过接口或抽象类定义装饰器规范，可以在不修改原有代码的情况下，动态地添加新的功能。

# 里氏替换原则

定义：如果 S 是 T 的子类型，那么可以将类型为 T 的对象替换为类型为 S 的对象，程序的行为不会发生变化。简单来说，就是如果一个函数接收的参数是某个类的实例，那么它也必须能够接收该类的任何子类的实例，而不会导致程序出现错误或异常。

解决的问题：

主要解决子类的设计和使用问题：

- 子类和父类之间的接口问题。在面向对象编程中，子类通常需要继承父类的接口，并且需要保证它们的行为是一致的。如果子类不遵守里氏替换原则，那么在替换父类时可能会破坏父类的接口约定，导致程序无法正常运行。
- 子类和父类之间的实现问题。在面向对象编程中，子类通常需要继承父类的实现，并且需要保证它们的实现是一致的。如果子类不遵守里氏替换原则，那么在替换父类时可能会破坏父类的实现约定，导致程序出现错误或异常。

收益：

- 提高代码的可维护性
- 提高代码的复用性
- 提高代码的健壮性
- 促进代码的扩展性
- 提高代码的可读性

实现方式：

- 通过接口实现：子类实现一个与父类相同的接口，保证子类可以完全替换父类，并且实现相同的功能。
- 通过抽象类实现：子类继承一个抽象类，保证子类可以完全替换父类，并且实现相同的功能。
- 通过重载实现：子类重载父类的方法，保证子类可以完全替换父类，并且实现相同的功能。
- 通过约束条件实现：在父类中添加一些约束条件，子类需要满足这些条件才能替换父类，从而保证子类的替换性和稳定性。
- 通过设计模式实现：一些设计模式，比如模板方法、工厂方法、策略模式等，都是基于里氏替换原则进行设计的，可以通过使用这些设计模式来实现里氏替换原则。
